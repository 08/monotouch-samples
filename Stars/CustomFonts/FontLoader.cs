using System;
using System.Linq;
using System.IO;

using MonoTouch.CoreText;
using MonoTouch.Foundation;
using System.Collections.Generic;
using MonoTouch.UIKit;
using MonoTouch.CoreGraphics;
using MonoTouch.CoreFoundation;

namespace CustomFonts
{
	public class FontLoader
	{
		private static FontLoader sharedFontLoader = null;
		NSMutableDictionary fonts;

		//private constructor for singleton implementation		
		private FontLoader ()
		{
			fonts = InitializeFonts ();
		}

		public static FontLoader SharedFontLoader {
			get {
				//implement singleton
				if (sharedFontLoader == null) {
					sharedFontLoader = new FontLoader ();
				}
				return sharedFontLoader;
			}
		}

		public NSMutableDictionary InitializeFonts ()
		{
			var fontsDict = new NSMutableDictionary ();

			//Get the information for fonts that we've embedded	either as code or in a designated plist
			//The CopyGeneratedFontDataMap is auto-generated by the GendEmbeddedFont tool/target in GeneratedFonts.m			

			return fontsDict;
		}

		public void AddFontFilesAndNames (string[] fileNames, string[] fontNames, string path)
		{

		}

		public void RemoveFontsWithNames (string[] names)
		{
			//unloadFont(obj);
			//fonts.Remove (obj);
		}

		public CGFont LoadFont (string name, bool registerFont)
		{
			var fontValue = fonts.ObjectForKey (new NSString (name));

			if (fontValue == null) {
				//We are not tracking this font in our class. Possibly a request for
				//an already registered font
				return null;
			}

			CGFont result = null;

			if (fontValue is GenFontData) {
				CGDataProvider dataProvider = null;
				var embeddedFont = (GenFontData)fonts.ObjectForKey (new NSString (name));
				var cgFont = (CGFont)embeddedFont.cgFont;

				if (cgFont != null) {
					if (registerFont && embeddedFont.registered == false) {
						NSError err = null;
						if (CTFontManager.RegisterGraphicsFont (cgFont, out err)) {
							embeddedFont.registered = true;
						}

						if (err != null) {
							Console.WriteLine (err);
							err.Dispose ();
						}
					}
					result = cgFont;
				} else if (embeddedFont.length != 0) {
					dataProvider = new CGDataProvider (embeddedFont.data, embeddedFont.length);
				} else {
					var genFontsPath = NSBundle.MainBundle.PathForResource ("SupportingData", "plist");
					if (genFontsPath != null) {
						var getFontsDict = NSDictionary.FromFile (genFontsPath);
						if (getFontsDict != null) {
							var fontData = getFontsDict.ObjectForKey (new NSString (embeddedFont.data));
							if (fontData != null) {
								//dataProvider = CGDataProviderCreateWithCFData((CFDataRef)fontData);
							}
						}
					}
				}
				if (dataProvider != null) {
					var cfont = CGFont.CreateFromProvider (dataProvider);
					if (cfont != null) {
						embeddedFont.cgFont = cfont;
						if (registerFont) {
							NSError err = null;
							if (CTFontManager.RegisterGraphicsFont (cgFont, out err)) { 
								embeddedFont.registered = true;
							}
							if (err != null) {
								Console.WriteLine (err);
								err.Dispose ();
							}
						}
						cfont.Dispose ();
						cgFont.Dispose ();
					}
					dataProvider.Dispose ();
					result = (CGFont)embeddedFont.cgFont;
				}
			} else if (fontValue is NSMutableArray) {
				var fontFileInfo = new List<object> ();
				var url = (NSUrl)fontFileInfo.ElementAt (0);
				var fileFontData = (GenFontData)fontFileInfo.ElementAt (1);
				if (fileFontData.cgFont != null) {
					NSError err = null;
					err = (CTFontManager.RegisterFontsForUrl (url, CTFontManagerScope.Process));
					if (err == null) {
						var cgFont = CGFont.CreateWithFontName (name);
						if (cgFont != null) {
							fileFontData.cgFont = cgFont;
							fileFontData.registered = registerFont;
							cgFont.Dispose ();
						}

						if (!registerFont) {
							err = CTFontManager.UnregisterFontsForUrl ((NSUrl)fontFileInfo.ElementAt (1), CTFontManagerScope.Process);
						}
					}

					if (err != null) {
						Console.WriteLine (err);
						err.Dispose ();
					}
				}
				result = (CGFont)fileFontData.cgFont;
			
			} else {
				//Unknown??
				return null;
			}
	
			return result;
		}

		public bool UnloadFont (string name)
		{
			bool result = false;
			var key = new NSString (name);

			var fontValue = fonts.ObjectForKey (key);

			if (fontValue is GenFontData) {
				var embeddedFont = (GenFontData)fonts.ObjectForKey (key);
				if (embeddedFont.cgFont == null) {
					return true;
				}

				NSError err = null;
				result = CTFontManager.UnregisterGraphicsFont (embeddedFont.cgFont, out err);
				embeddedFont.cgFont = null;
			} else if (fontValue is NSUrl) { 
				var temp = (NSMutableArray)fontValue;
				object[] array = NSArray.FromArray <NSArray> (temp);
				var fontFileInfo = array.ToList ();
				var url = fontFileInfo.ElementAt (0);
				var fileFontData = (GenFontData)fontFileInfo.ElementAt (1);
				if (fileFontData != null) {
					if (fileFontData.registered) {
						NSError err = null;
						err = CTFontManager.RegisterFontsForUrl ((NSUrl)url, CTFontManagerScope.Process);
						if (err != null) {
							Console.WriteLine (err);
							err.Dispose ();
						}
					}
					fileFontData.cgFont = null;
					fileFontData.registered = false;
				}
			} else {
				//Registered font, no need to load it
				result = true;
			}
			return result;
		}

		public List<UIFont> AvailableFonts ()
		{
			// return fonts.allKeys.sortedArrayUsingSelector("compare");
			return null;
		}

		public UIFont FontWithName (string name, float size)
		{
			LoadFont (name, true);
			return UIFont.FromName (name, size);
		}

		public CTFont HiddenFontWithName (string name, float size)
		{
			var cgFont = LoadFont (name, false);
			if (cgFont != null) {
				return new CTFont (cgFont, size, null);
			}

			return null;
		}
	}
}